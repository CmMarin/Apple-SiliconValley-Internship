from typing import List, Dict
import re
from datetime import datetime, timedelta

# Improved regular expressions for task extraction
SPLIT_RE = re.compile(r"[\.\n;•]+")

# Time patterns (more comprehensive)
TIME_RE = re.compile(r"\b(\d{1,2}[:\.]\d{2}\s*(?:am|pm|AM|PM)?|\d{1,2}\s*(?:am|pm|AM|PM))\b")
# Time with "at" or "la" prefix
TIME_PREFIX_RE = re.compile(r"(?:at|la|@)\s*(\d{1,2}[:\.]\d{2}\s*(?:am|pm|AM|PM)?|\d{1,2}\s*(?:am|pm|AM|PM))")

# Date patterns (more comprehensive)
DATE_RE = re.compile(r"\b(\d{1,2}[\/\-\.]\d{1,2}(?:[\/\-\.]\d{2,4})?|\d{1,2}(?:st|nd|rd|th)?\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|ian|feb|mar|apr|mai|iun|iul|aug|sep|oct|nov|dec)(?:uary|ruary|ch|il|e|y|ust|tember|ober|ember)?(?:\s+\d{2,4})?)\b", re.IGNORECASE)
# Date with deadline prefixes
DEADLINE_PREFIX_RE = re.compile(r"(?:by|până la|before|until|due|deadline)\s+(\d{1,2}[\/\-\.]\d{1,2}(?:[\/\-\.]\d{2,4})?|\d{1,2}(?:st|nd|rd|th)?\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|ian|feb|mar|apr|mai|iun|iul|aug|sep|oct|nov|dec)(?:uary|ruary|ch|il|e|y|ust|tember|ober|ember)?(?:\s+\d{2,4})?|tomorrow|mâine|maine|today|astăzi|azi|next\s+(?:week|month|monday|tuesday|wednesday|thursday|friday|saturday|sunday|săptămână|luni|marți|miercuri|joi|vineri|sâmbătă|duminică))", re.IGNORECASE)
# Relative dates
RELATIVE_DATE_RE = re.compile(r"\b(tomorrow|mâine|maine|today|astăzi|azi|next\s+(?:week|month|monday|tuesday|wednesday|thursday|friday|saturday|sunday|săptămână|luni|marți|miercuri|joi|vineri|sâmbătă|duminică))\b", re.IGNORECASE)
# Romanian days of the week
ROMANIAN_DAYS_RE = re.compile(r"\b(luni|marți|miercuri|joi|vineri|sâmbătă|duminică)\b", re.IGNORECASE)

# Task intention markers in Romanian
ROMANIAN_TASK_MARKERS = [
    "trebuie", "să", "ar trebui", "vreau să", "voi", "o să", "va trebui", 
    "trebuie să", "am nevoie", "am de", "o să", "trebuie de", "va fi", "să fac",
    "programare", "programat", "duc", "mă duc", "merg"
]

# Enhanced greeting detection
GREETING_PATTERNS = [
    r"^(?:hi|hey|hello|salut|bună|buna)\s+\w+",  # Hi John
    r"^(?:good)\s+(?:morning|afternoon|evening|day)",  # Good morning
    r"(?:greetings|salutations)",  # Formal greetings
    r"^(?:how are you|how's it going|ce mai faci|cum esti)",  # Common greeting questions
]
GREETING_TERMS = {
    "hi", "hello", "hey", "good morning", "good afternoon", "good evening",
    "salut", "bună", "buna", "bună ziua", "buna ziua", "noroc", "servus"
}

# Normalized days of week mapping to day index (0 = Monday)
DAYS_OF_WEEK = {
    "monday": 0, "tuesday": 1, "wednesday": 2, "thursday": 3, "friday": 4, "saturday": 5, "sunday": 6,
    "luni": 0, "marți": 1, "marti": 1, "miercuri": 2, "joi": 3, "vineri": 4, "sâmbătă": 5, "sambata": 5, 
    "duminică": 6, "duminica": 6
}

def is_greeting(text: str) -> bool:
    """
    Enhanced function to detect if text is primarily a greeting
    """
    text = text.lower().strip()
    
    # Check if text is just a common greeting term
    if text in GREETING_TERMS:
        return True
        
    # Check greeting patterns
    for pattern in GREETING_PATTERNS:
        if re.search(pattern, text, re.IGNORECASE):
            # If the match is the majority of the text, it's a greeting
            match = re.search(pattern, text, re.IGNORECASE)
            if match and len(match.group(0)) / len(text) > 0.6:
                return True
                
    return False

def normalize_date(date_text: str) -> str:
    """
    Convert relative dates to absolute dates.
    For example, 'tomorrow' becomes '2023-09-20' (if today is 2023-09-19).
    """
    if not date_text:
        return date_text
        
    # Convert to lowercase for better matching
    date_text = date_text.lower().strip()
    
    # Handle direct relative dates
    relative_dates = {
        "today": 0,
        "tomorrow": 1,
        "day after tomorrow": 2,
        "next week": 7,
        "azi": 0,
        "astăzi": 0,
        "mâine": 1,
        "maine": 1,
        "poimâine": 2,
        "poimaine": 2,
        "săptămâna viitoare": 7,
        "saptamana viitoare": 7
    }
    
    if date_text in relative_dates:
        days_to_add = relative_dates[date_text]
        return (datetime.now() + timedelta(days=days_to_add)).strftime("%Y-%m-%d")
    
    # Handle "next [day of week]"
    next_day_match = re.match(r"next\s+(\w+)", date_text)
    if next_day_match:
        day_name = next_day_match.group(1).lower()
        if day_name in DAYS_OF_WEEK:
            # Calculate days until next occurrence of this day
            today = datetime.now().weekday()
            day_index = DAYS_OF_WEEK[day_name]
            days_until = (day_index - today) % 7
            if days_until == 0:  # If today is the day, go to next week
                days_until = 7
            return (datetime.now() + timedelta(days=days_until)).strftime("%Y-%m-%d")
    
    # Handle single day of week (e.g., "Monday", "vineri")
    if date_text in DAYS_OF_WEEK:
        today = datetime.now().weekday()
        day_index = DAYS_OF_WEEK[date_text]
        days_until = (day_index - today) % 7
        # If today is mentioned day and it's already past working hours, go to next week
        if days_until == 0 and datetime.now().hour >= 17:
            days_until = 7
        return (datetime.now() + timedelta(days=days_until)).strftime("%Y-%m-%d")
    
    # Return the original if no match
    return date_text

def extract_tasks(input_text: str) -> List[Dict[str, str]]:
    """
    Enhanced task extraction with improved time, date, and deadline detection
    for both English and Romanian text.
    """
    tasks: List[Dict[str, str]] = []
    
    # Skip if input is just a greeting
    if is_greeting(input_text) and len(input_text.split()) <= 5:
        return tasks
        
    # Special handling for common Romanian task expressions
    text_lower = input_text.lower()
    has_romanian_markers = any(marker in text_lower for marker in ROMANIAN_TASK_MARKERS)
    has_romanian_date = "maine" in text_lower or "mâine" in text_lower or "azi" in text_lower or "astăzi" in text_lower or ROMANIAN_DAYS_RE.search(text_lower)
    
    # Split by delimiters and filter empty lines
    raw_parts = SPLIT_RE.split(input_text)
    
    # If we suspect this is a simple Romanian task, don't split too aggressively
    if len(raw_parts) == 1 and (has_romanian_markers or has_romanian_date):
        s = input_text.strip(" -•\t*")
        
        time = None
        deadline = None
        
        # Extract time
        time_prefix_match = TIME_PREFIX_RE.search(s)
        if time_prefix_match:
            time = time_prefix_match.group(1)
        else:
            time_match = TIME_RE.search(s)
            if time_match:
                time = time_match.group(1)
        
        # Extract deadline
        if "maine" in s.lower() or "mâine" in s.lower():
            deadline = normalize_date("mâine")
        elif "azi" in s.lower() or "astăzi" in s.lower():
            deadline = normalize_date("azi")
        else:
            # Check for Romanian days of the week
            day_match = ROMANIAN_DAYS_RE.search(s)
            if day_match:
                deadline = normalize_date(day_match.group(1))
            else:
                # Try other date patterns
                deadline_match = DEADLINE_PREFIX_RE.search(s) or DATE_RE.search(s) or RELATIVE_DATE_RE.search(s)
                if deadline_match:
                    raw_deadline = deadline_match.group(1)
                    deadline = normalize_date(raw_deadline)
        
        # For Romanian, extract a reasonable task description
        if has_romanian_markers:
            category = "Shopping" if "magazin" in s.lower() else categorize_task(s)
            tasks.append({
                "task": s,
                "time": time,
                "deadline": deadline,
                "category": category
            })
            return tasks
    
    # Standard processing for other inputs
    for raw in raw_parts:
        s = raw.strip(" -•\t*")
        if not s:
            continue
            
        # Filter trivial tokens and common greetings/phrases
        if len(s) < 3 or re.fullmatch(r"[A-Za-z]", s) or s.lower() in {
            "hi", "hello", "salut", "hey", "thanks", "thank you", "mulțumesc", 
            "ok", "okay", "sure", "yes", "no", "da", "nu"
        }:
            continue

        time = None
        deadline = None
        
        # Extract time with priority to time with prefixes
        time_prefix_match = TIME_PREFIX_RE.search(s)
        if time_prefix_match:
            time = time_prefix_match.group(1)
            # Remove the matched part from task text
            s = s.replace(time_prefix_match.group(0), " ")
        else:
            time_match = TIME_RE.search(s)
            if time_match:
                time = time_match.group(1)
                # Keep time in task text as it might be part of the task description
        
        # Extract deadline with priority to deadlines with prefixes
        deadline_prefix_match = DEADLINE_PREFIX_RE.search(s)
        if deadline_prefix_match:
            raw_deadline = deadline_prefix_match.group(1)
            deadline = normalize_date(raw_deadline)
            # Remove the matched part from task text
            s = s.replace(deadline_prefix_match.group(0), " ")
        else:
            # Try matching a date without prefix
            date_match = DATE_RE.search(s)
            if date_match:
                raw_deadline = date_match.group(1)
                deadline = normalize_date(raw_deadline)
                # Keep date in task text as it might be part of the task description
            else:
                # Try relative dates
                relative_date_match = RELATIVE_DATE_RE.search(s)
                if relative_date_match:
                    raw_deadline = relative_date_match.group(1)
                    deadline = normalize_date(raw_deadline)
                    # Keep date in task text as it might be part of the task description
        
        # Process the task text: normalize whitespace
        s = re.sub(r'\s+', ' ', s).strip()
        
        task = {
            "task": s,
            "time": time,
            "deadline": deadline,
            "category": categorize_task(s),
        }
        tasks.append(task)

    return tasks

def categorize_task(task: str) -> str:
    """
    Enhanced categorization logic based on keyword matching for both English and Romanian.
    """
    # Convert to lowercase for case-insensitive matching
    task_lower = task.lower()
    
    # Work/Office related keywords
    work_keywords = [
        # English
        "work", "meeting", "call", "project", "deadline", "presentation", "client", 
        "email", "report", "document", "office", "boss", "colleague", "conference",
        # Romanian
        "muncă", "întâlnire", "apel", "proiect", "prezentare", "client", 
        "email", "raport", "document", "birou", "șef", "coleg"
    ]
    
    # Family/Home related keywords
    family_keywords = [
        # English
        "family", "kid", "child", "parent", "mom", "dad", "school", "homework",
        # Romanian
        "familie", "copil", "părinte", "mama", "tata", "școală", "temă"
    ]
    
    # Home related keywords
    home_keywords = [
        # English
        "house", "home", "clean", "cook", "dinner", "lunch", "breakfast",
        "laundry", "dishes", "chore", "apartment",
        # Romanian
        "casă", "acasă", "curăț", "gătit", "cină", "prânz", "mic dejun",
        "rufe", "vase", "apartament"
    ]
    
    # Shopping/Errands keywords
    shopping_keywords = [
        # English
        "buy", "purchase", "shop", "store", "groceries", "market", "mall",
        "order", "deliver", "amazon", "online",
        # Romanian
        "cumpără", "achiziție", "magazin", "cumpărături", "piață", "mall",
        "comandă", "livrare", "online", "fructe", "legume"
    ]
    
    # Health/Medical keywords
    health_keywords = [
        # English
        "doctor", "appointment", "medicine", "prescription", "health", "medical",
        "workout", "exercise", "gym", "fitness", "dentist", "hospital",
        # Romanian
        "doctor", "medic", "programare", "medicament", "rețetă", "sănătate", 
        "antrenament", "exercițiu", "sală", "fitness", "dentist", "spital"
    ]
    
    # Finance/Bills keywords
    finance_keywords = [
        # English
        "pay", "bill", "invoice", "money", "bank", "account", "tax", "payment",
        "finance", "budget", "salary", "debt", "loan",
        # Romanian
        "plată", "factură", "bani", "bancă", "cont", "taxă", "impozit",
        "finanțe", "buget", "salariu", "datorie", "împrumut"
    ]
    
    # Travel/Transportation keywords
    travel_keywords = [
        # English
        "trip", "travel", "flight", "airport", "hotel", "vacation", "booking",
        "car", "drive", "bus", "train", "ticket", "reservation",
        # Romanian
        "călătorie", "zbor", "aeroport", "hotel", "vacanță", "rezervare",
        "mașină", "conducere", "autobuz", "tren", "bilet"
    ]
    
    # Study/Education keywords
    study_keywords = [
        # English
        "study", "learn", "course", "class", "lecture", "exam", "test",
        "homework", "assignment", "book", "read", "research", "paper",
        # Romanian
        "studiu", "învăța", "curs", "clasă", "lecție", "examen", "test",
        "temă", "carte", "citit", "cercetare", "lucrare"
    ]
    
    # Personal keywords
    personal_keywords = [
        # English
        "personal", "myself", "my own", "private", "me time", "self care",
        # Romanian
        "personal", "eu însumi", "privat", "timp personal", "îngrijire personală"
    ]
    
    # Check for each category
    for keyword in work_keywords:
        if keyword in task_lower:
            return "Work"
            
    for keyword in family_keywords:
        if keyword in task_lower:
            return "Family"
            
    for keyword in home_keywords:
        if keyword in task_lower:
            return "Home"
            
    for keyword in shopping_keywords:
        if keyword in task_lower:
            return "Shopping"
            
    for keyword in health_keywords:
        if keyword in task_lower:
            return "Health"
            
    for keyword in finance_keywords:
        if keyword in task_lower:
            return "Finance"
            
    for keyword in travel_keywords:
        if keyword in task_lower:
            return "Travel"
            
    for keyword in study_keywords:
        if keyword in task_lower:
            return "Study"
            
    for keyword in personal_keywords:
        if keyword in task_lower:
            return "Personal"
    
    # Check for specific categories based on task markers
    if "#work" in task_lower or "(work)" in task_lower:
        return "Work"
    elif "#home" in task_lower or "(home)" in task_lower:
        return "Home"
    elif "#family" in task_lower or "(family)" in task_lower:
        return "Family"
    elif "#shop" in task_lower or "(shop)" in task_lower:
        return "Shopping"
    elif "#health" in task_lower or "(health)" in task_lower:
        return "Health"
    elif "#finance" in task_lower or "(finance)" in task_lower:
        return "Finance"
    elif "#travel" in task_lower or "(travel)" in task_lower:
        return "Travel"
    elif "#study" in task_lower or "(study)" in task_lower:
        return "Study"
    elif "#personal" in task_lower or "(personal)" in task_lower:
        return "Personal"
    
    # Default to Personal
    return "Personal"